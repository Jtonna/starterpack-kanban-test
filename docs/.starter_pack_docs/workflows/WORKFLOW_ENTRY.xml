<workflow name="ENTRY">

  <overview>
    Defines how work enters the system, how the orchestrator routes it to the correct
    workflow strategy, and how scope is enforced during execution. Every change to the
    codebase must be tied to a beads ticket — no exceptions.
  </overview>

  <entry-points>
    <!--
      Work can arrive in three forms. The orchestrator must identify which type it is
      and route accordingly. If the request does not clearly match one of these, ask
      the human to clarify before proceeding.
    -->

    <entry name="EXISTING_TICKET">
      <description>A beads ticket already exists (the human says "work on KAN-29b" or the orchestrator picks one from "bd ready").</description>
      <action>Run "bd show ID" to read the ticket, then proceed to PLANNING workflow.</action>
      <status-message>executing ENTRY/EXISTING_TICKET — loading {ticket-id}</status-message>
    </entry>

    <entry name="SPEC_FILE">
      <description>
        The human points to a spec file (e.g. SPEC.md) or provides a large feature description
        that needs to be broken into multiple tickets before work can begin.
      </description>
      <actions>
        <action>Read the spec file</action>
        <action>Create an epic ticket summarizing the full scope: bd create --type epic --title "..." --description "..."</action>
        <action>
          Decompose the spec into individual feature/task tickets. For each:
          - bd create --type feature|task --title "..." --description "..."
          Do NOT create dependencies between children and the epic — the epic is a tracking
          container, not a blocker. The orchestrator tracks which tickets belong to the epic.
        </action>
        <action>
          Establish dependencies between child tickets where ordering matters:
          - bd dep add {later-ticket} {earlier-ticket}
          Only add deps between children that have real sequential dependencies.
        </action>
        <action>Present the full ticket breakdown to the human for approval before starting any work</action>
        <gate>BLOCKED — Do not proceed. Human approval of the ticket breakdown is required before starting any child ticket work.</gate>
        <action>Once approved, run the beads-sync-protocol to push ticket changes to main (see below)</action>
        <action>Pick the first ready ticket (bd ready) and proceed to PLANNING workflow</action>
      </actions>
      <status-message>executing ENTRY/SPEC_FILE — decomposing spec into tickets</status-message>
    </entry>

    <entry name="AD_HOC_REQUEST">
      <description>
        The human gives an instruction directly (e.g. "add a logout button", "fix the header alignment").
        This is NOT a ticket yet.
      </description>
      <actions>
        <action>
          Before doing any work, create a beads ticket:
          - bd create --type feature|bug|task --title "..." --description "..."
          - Use the human's request as the description basis
        </action>
        <action>Confirm the ticket with the human: "Created {ticket-id}: {title}. Proceeding with this."</action>
        <action>Run the beads-sync-protocol to push ticket changes to main (see below)</action>
        <action>Proceed to PLANNING workflow with the new ticket</action>
      </actions>
      <rule>
        Never implement an ad-hoc request without a ticket. The ticket is the audit trail.
        If the human insists on skipping the ticket, explain that every change must be tracked
        for traceability and push back respectfully.
      </rule>
      <status-message>executing ENTRY/AD_HOC_REQUEST — creating ticket for request</status-message>
    </entry>
  </entry-points>

  <branching-strategy>
    <!--
      Two strategies exist. The orchestrator selects the appropriate one based on the
      scope of the work. Both strategies always use branches — never commit directly to main.
    -->

    <strategy name="TRUNK_BASED">
      <description>
        For single tickets with small, well-defined scope. One short-lived branch per ticket.
        The branch is created, work is done, and the PR is merged in the same session or shortly after.
      </description>
      <when>
        - The ticket is a single feature, bug, task, or chore
        - The scope fits in one planning/implementation cycle
        - No child tickets or decomposition needed
      </when>
      <flow>
        One ticket → one branch (TYPE/ticket-id) → full workflow (PLANNING → IMPLEMENTATION → DOCS → PR) → merge → delete branch
      </flow>
    </strategy>

    <strategy name="FEATURE_BRANCHING">
      <description>
        For epics or large features that decompose into multiple tickets. One long-lived
        feature branch hosts all child ticket work. Child tickets do NOT get their own branches.
      </description>
      <when>
        - The work originated from a SPEC_FILE entry or was identified as an epic during PLANNING/INTAKE
        - Multiple child tickets exist under an epic
      </when>
      <flow>
        Epic ticket → create long-lived branch (EPIC/epic-id) → for each child ticket in dependency order:
          run PLANNING → IMPLEMENTATION on the same branch → close child ticket
        → once all children complete: DOCS (full epic diff against main) → PR → merge → close epic → delete branch
      </flow>
      <rules>
        <rule>All child tickets commit to the epic branch, not their own branches</rule>
        <rule>Each child ticket runs PLANNING → IMPLEMENTATION only (not DOCS or PR)</rule>
        <rule>DOCS runs once after all children are complete, diffing the full epic branch against main</rule>
        <rule>PR runs once at the end for the entire epic, after DOCS</rule>
        <rule>The epic ticket is closed only after all children are closed and the PR is merged</rule>
        <rule>Sub-task progress for each child ticket is tracked as comments on the child ticket</rule>
      </rules>
    </strategy>

    <selection>
      The orchestrator determines the strategy during entry point routing:
      - SPEC_FILE entry → FEATURE_BRANCHING (always)
      - EXISTING_TICKET with type "epic" → FEATURE_BRANCHING
      - EXISTING_TICKET with any other type → TRUNK_BASED
      - AD_HOC_REQUEST → TRUNK_BASED (unless the orchestrator determines during PLANNING/INTAKE that it should be an epic)
    </selection>
  </branching-strategy>

  <beads-sync-protocol>
    <!--
      Reusable protocol for syncing beads ticket changes to main. This ensures
      ticket creation and closing events reach main so the GitHub Actions beads-sync
      workflow triggers. This protocol is autonomous — no human gate required.

      Triggers:
      - After ticket creation (ENTRY/SPEC_FILE, ENTRY/AD_HOC_REQUEST)
      - After child ticket close (IMPLEMENTATION/HANDOFF in FEATURE_BRANCHING)
      - After final ticket close (PR/SUBMIT)

      Does NOT trigger for:
      - Sub-task comment updates (bd comment) — these stay local until the feature branch merges
      - Status changes to in_progress — low-priority metadata
    -->

    <steps>
      <step order="1">Note the current branch (or "main" if not on a branch yet)</step>
      <step order="2">Switch to main and pull latest: git checkout main && git pull</step>
      <step order="3">Create a short-lived sync branch: git checkout -b BEADS/sync-{ticket-id}</step>
      <step order="4">Run bd sync to export changes to .beads/issues.jsonl</step>
      <step order="5">Stage only .beads/ files: git add .beads/</step>
      <step order="6">Commit: "{ticket-id}: sync beads tickets"</step>
      <step order="7">Push: git push -u origin BEADS/sync-{ticket-id}</step>
      <step order="8">Create and auto-merge PR: gh pr create --title "beads: sync tickets" --body "Automated beads sync" && gh pr merge --merge --delete-branch</step>
      <step order="9">Switch back to the previous branch: git checkout {previous-branch}</step>
      <step order="10">Pull main into the working branch if on a feature/epic branch: git merge main (to pick up the beads changes)</step>
    </steps>

    <rules>
      <rule>Only .beads/ files go on BEADS/ branches — never code, never docs</rule>
      <rule>This is fully autonomous — no human approval needed</rule>
      <rule>If the merge into the working branch has conflicts (unlikely for .beads/ files), stop and ask the human</rule>
      <rule>The orchestrator delegates this to a submitter agent (light tier) — it never runs git commands itself</rule>
    </rules>

    <status-message>executing BEADS_SYNC — syncing ticket changes to main</status-message>
  </beads-sync-protocol>

  <scope-enforcement>
    <!--
      This is a hard rule. Every agent in the hierarchy must respect scope boundaries.
      The orchestrator enforces this at the top level, and implementation teammates enforce
      it at the code level.
    -->

    <rule name="NO_UNTRACKED_CHANGES">
      Every change to the codebase must be tied to a beads ticket. No exceptions.
      This is the audit trail. If a change is not in a ticket, it does not get implemented.
    </rule>

    <rule name="PUSH_BACK_ON_SCOPE_CREEP">
      If the human requests a change that falls outside the current ticket's scope during
      any workflow phase:
      1. Acknowledge the request
      2. Explain that it falls outside the current ticket scope ({ticket-id}: {title})
      3. Offer to create a new ticket to track the requested change
      4. If the human agrees, create the ticket and continue with the original work
      5. If the human insists on doing it now, create the ticket first, then pause the current
         ticket and switch to the new one — the change still gets tracked

      Never silently incorporate out-of-scope changes. The goal is not to block the human
      but to ensure every change has a ticket for traceability.
    </rule>

    <rule name="AGENT_SCOPE_ENFORCEMENT">
      Implementation teammates must only modify files specified in their sub-task.
      If a teammate discovers that out-of-scope changes are needed:
      1. Stop work on the out-of-scope change
      2. Report back to the orchestrator (team lead) with what was discovered
      3. The orchestrator creates a new ticket for the out-of-scope work and informs the human
      4. The original sub-task continues without the out-of-scope change
    </rule>
  </scope-enforcement>

</workflow>
