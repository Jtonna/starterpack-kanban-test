<workflow name="IMPLEMENTATION">

  <overview>
    Executed after a plan is approved in the Planning workflow. The orchestrator launches
    a Swarm Manager to coordinate implementation agents. The orchestrator does NOT manage
    individual agents — the swarm manager handles dispatch, monitoring, and escalation.
  </overview>

  <loop>
    <!--
      LAUNCH → DISPATCH → MONITOR → EVALUATE → REPORT → HUMAN_GATE → HANDOFF
                  ▲           │
                  │  failure   │
                  └─ ESCALATE ─┘
                       │
                       │ stuck → orchestrator → human
    -->

    <phase name="LAUNCH" order="1">
      <actor>Orchestrator launches a Swarm Manager agent (reasoning tier)</actor>

      <actions>
        <action>Pass the approved plan, ticket ID, ticket issue_type, and branching strategy to the swarm manager</action>
        <action>
          Branch handling depends on the branching strategy (set during ENTRY workflow):

          TRUNK_BASED: The swarm manager creates a new branch before dispatching any agents.
          Branch naming: look up the ticket's issue_type in docs/.starter_pack_docs/workflows/BEADS.xml issue-types
          to find the corresponding branch-prefix.
          Example: issue_type "feature" → branch-prefix "FEAT/" → git checkout -b FEAT/sp-0004

          FEATURE_BRANCHING: The swarm manager checks if the epic branch (EPIC/epic-id) exists.
          If it does not exist (first child ticket), create it: git checkout -b EPIC/epic-id
          If it already exists (subsequent child tickets), check it out: git checkout EPIC/epic-id
          All child ticket commits go to the same epic branch.
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/LAUNCH on {ticket-id} with swarm manager</status-message>
    </phase>

    <phase name="DISPATCH" order="2">
      <actor>Swarm Manager</actor>

      <actions>
        <action>Read the plan's sub-task list and dependency ordering</action>
        <action>
          For each sub-task, determine the model tier using the planner's complexity rating
          (see docs/.starter_pack_docs/workflows/MODELS.xml dispatch-override section):
          - light complexity → haiku (light tier)
          - standard complexity → sonnet (worker tier)
          - complex complexity → opus (reasoning tier)
        </action>
        <action>Launch independent sub-tasks in parallel</action>
        <action>Launch dependent sub-tasks sequentially after their dependencies complete</action>
        <action>
          Each implementation agent receives:
          - The sub-task description, files to modify, acceptance criteria
          - The branch to commit to
          - The ticket ID for commit messages
          - The full escalation protocol from docs/.starter_pack_docs/workflows/MODELS.xml escalation-rules/implementation-agents
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/DISPATCH on {ticket-id} — launching {N} agents</status-message>
    </phase>

    <phase name="MONITOR" order="3">
      <actor>Swarm Manager</actor>

      <actions>
        <action>Collect results from each implementation agent as they complete</action>
        <action>Track: success/failure, files modified, commits made</action>
        <action>
          For failed agents, collect the structured failure report:
          - What was attempted
          - The error encountered
          - Files involved
          - What was committed (if partial work was saved)
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/MONITOR on {ticket-id} — {N}/{total} complete</status-message>
    </phase>

    <phase name="EVALUATE" order="4">
      <actor>Swarm Manager</actor>

      <on-success>All agents succeeded → proceed to REPORT</on-success>

      <on-failure>
        <action>Launch an Escalation Agent (reasoning tier) with the failure context</action>
        <action>If escalation agent resolves the issue → re-dispatch remaining work (loop to DISPATCH)</action>
        <action>If escalation agent also fails → escalate to orchestrator for human input</action>
      </on-failure>

      <status-message>executing IMPLEMENTATION/EVALUATE on {ticket-id} — {N} failures, escalating</status-message>
    </phase>

    <phase name="REPORT" order="5">
      <actor>Swarm Manager reports back to Orchestrator</actor>

      <report-contents>
        <item>Summary of all changes made</item>
        <item>Files modified per sub-task</item>
        <item>All commit hashes</item>
        <item>Any warnings or concerns noted during implementation</item>
      </report-contents>

      <status-message>executing IMPLEMENTATION/REPORT on {ticket-id} — swarm complete</status-message>
    </phase>

    <phase name="HUMAN_GATE" order="6">
      <actor>Orchestrator presents to the human</actor>

      <presents>
        <item>Summary of what was implemented</item>
        <item>Files modified</item>
        <item>How to verify/test the changes</item>
        <item>Any concerns raised by the swarm manager</item>
      </presents>

      <gate>BLOCKED — Do not proceed. Human approval required before continuing.</gate>
      <on-rejection>Orchestrator passes feedback to swarm manager → loop to DISPATCH</on-rejection>
      <status-message>awaiting IMPLEMENTATION/HUMAN_GATE on {ticket-id} — BLOCKED: human approval required</status-message>
    </phase>

    <phase name="HANDOFF" order="7">
      <description>
        TRUNK_BASED: proceed to the DOCS workflow.
        FEATURE_BRANCHING: close the child ticket, then run the beads-sync-protocol
        (see WORKFLOW_ENTRY.xml) to push the ticket close to main. Return to the orchestrator.
        The orchestrator picks the next ready child ticket, or proceeds to DOCS if all children are complete.
      </description>
      <status-message>executing IMPLEMENTATION/HANDOFF on {ticket-id} — transitioning to DOCS</status-message>
    </phase>

  </loop>

  <agent-rules>
    <!--
      These rules MUST be included in the instructions given to every implementation agent.
      The swarm manager is responsible for passing these to each agent it dispatches.
    -->

    <section name="commit-discipline">
      <rule>
        Every commit message starts with the ticket ID being worked (discover prefix from beads, never guess).
        In FEATURE_BRANCHING, use the child ticket ID, not the epic ID. The epic branch name
        already ties everything together.
      </rule>
      <rule>Commits must be granular — one logical change per commit</rule>
      <rule>Multiple commits per sub-task are expected</rule>
      <rule>Each commit must be atomic and independently valid (builds, no broken imports)</rule>
      <rule>Never commit secrets, .env files, or credentials</rule>
    </section>

    <section name="escalation-protocol">
      <!--
        This is the full escalation chain. Workers must understand what happens
        after they report a failure so they know they are not dying in a void.
      -->
      <rule order="1">If you encounter an error, retry once with a different approach</rule>
      <rule order="2">If the retry fails, stop immediately</rule>
      <rule order="3">Commit any partial work that is valid</rule>
      <rule order="4">
        Return a structured failure report to the swarm manager:
          FAILURE REPORT
          Sub-task: {description}
          Attempted: {what was tried}
          Error: {the error}
          Files involved: {list}
          Partial work committed: yes/no
          Suggested fix: {if any}
      </rule>
      <rule order="5">
        What happens next (you do not need to handle this — just report and stop):
        → The swarm manager launches an Escalation Agent (reasoning tier) with your failure context
        → If the escalation agent resolves the issue, remaining work is re-dispatched
        → If the escalation agent also fails, it goes to the orchestrator → human for guidance
      </rule>
    </section>

    <section name="scope">
      <rule>Only modify files specified in the sub-task</rule>
      <rule>
        If changes to out-of-scope files are needed:
        1. Stop work on the out-of-scope change immediately
        2. Report back to the swarm manager with what was discovered and why it is needed
        3. Do NOT attempt the out-of-scope change — it will be tracked as a separate ticket
      </rule>
      <rule>Do not refactor, improve, or clean up code outside the sub-task scope</rule>
      <rule>
        Every change must be traceable to the ticket. If you cannot tie a change back to
        the sub-task description, do not make it.
      </rule>
    </section>

    <section name="sub-task-tracking">
      <!--
        The swarm manager tracks sub-task progress as comments on the parent beads ticket.
        This provides an audit trail visible in the ticket history.
        See also: WORKFLOW_PLANNING.xml sub-task-tracking for the initial plan posting rule.
      -->
      <rule>Before dispatching agents, post the sub-task plan as a comment on the ticket: bd comment {ticket-id} "..."</rule>
      <rule>As each sub-task completes, post a status update comment: "[sub-task N] DONE: {summary of changes}"</rule>
      <rule>On failure, post: "[sub-task N] FAILED: {error summary} — escalating"</rule>
    </section>
  </agent-rules>

</workflow>
