<workflow name="IMPLEMENTATION">

  <overview>
    Executed after a plan is approved in the Planning workflow. The orchestrator acts as Agent Team
    lead, directly spawning implementation teammates and coordinating their work. Sub-agents cannot
    spawn other sub-agents, so the orchestrator manages the team directly.
  </overview>

  <loop>
    <!--
      LAUNCH → DISPATCH → MONITOR → EVALUATE → HUMAN_GATE → HANDOFF
                  ▲           │
                  │  failure   │
                  └─ ESCALATE ─┘
                       │
                       │ stuck → human
    -->

    <phase name="LAUNCH" order="1">
      <actor>Orchestrator (acting as Agent Team lead)</actor>

      <actions>
        <action>Read the approved plan, ticket ID, ticket issue_type, and branching strategy</action>
        <action>
          Branch handling depends on the branching strategy (set during ENTRY workflow):

          TRUNK_BASED: The orchestrator creates a new branch before dispatching any teammates.
          Branch naming: look up the ticket's issue_type in docs/.starter_pack_docs/workflows/BEADS.xml issue-types
          to find the corresponding branch-prefix.
          Example: issue_type "feature" → branch-prefix "FEAT/" → git checkout -b FEAT/sp-0004

          FEATURE_BRANCHING: The orchestrator checks if the epic branch (EPIC/epic-id) exists.
          If it does not exist (first child ticket), create it: git checkout -b EPIC/epic-id
          If it already exists (subsequent child tickets), check it out: git checkout EPIC/epic-id
          All child ticket commits go to the same epic branch.
        </action>
        <action>Create the Agent Team for this implementation cycle</action>
      </actions>

      <status-message>executing IMPLEMENTATION/LAUNCH on {ticket-id} with team lead</status-message>
    </phase>

    <phase name="DISPATCH" order="2">
      <actor>Orchestrator (Team Lead)</actor>

      <actions>
        <action>Read the plan's sub-task list and dependency ordering</action>
        <action>
          For each sub-task, determine the model tier using the planner's complexity rating
          (see docs/.starter_pack_docs/workflows/MODELS.xml dispatch-override section):
          - light complexity → haiku (light tier)
          - standard complexity → sonnet (worker tier)
          - complex complexity → opus (reasoning tier)
        </action>
        <action>Spawn independent sub-tasks as teammates in parallel, each with its own model tier</action>
        <action>Spawn dependent sub-tasks as teammates sequentially after their dependencies complete</action>
        <action>
          Each implementation teammate receives:
          - The sub-task description, files to modify, acceptance criteria
          - The branch to commit to
          - The ticket ID for commit messages
          - The full escalation protocol from docs/.starter_pack_docs/workflows/MODELS.xml escalation-rules/implementation-agents
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/DISPATCH on {ticket-id} — launching {N} teammates</status-message>
    </phase>

    <phase name="MONITOR" order="3">
      <actor>Orchestrator (Team Lead)</actor>

      <actions>
        <action>Receive messages from teammates as they complete or encounter issues</action>
        <action>Track: success/failure, files modified, commits made</action>
        <action>
          For failed teammates, collect the structured failure report:
          - What was attempted
          - The error encountered
          - Files involved
          - What was committed (if partial work was saved)
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/MONITOR on {ticket-id} — {N}/{total} complete</status-message>
    </phase>

    <phase name="EVALUATE" order="4">
      <actor>Orchestrator (Team Lead)</actor>

      <on-success>All teammates succeeded → proceed to HUMAN_GATE</on-success>

      <on-failure>
        <action>Review the failure context and classify the failure type</action>
        <action>
          TECHNICAL FAILURE (logic bug, command error, test failure, syntax issue):
          Spawn an Opus (reasoning tier) teammate with the failure context to attempt resolution.
          If the Opus teammate resolves the issue → loop to DISPATCH for remaining work.
          If the Opus teammate also fails → present to human.
        </action>
        <action>
          REQUIREMENTS FAILURE (plan dictated something impossible, unclear spec, wrong direction,
          missing information, architectural decision needed):
          Present the failure to the human for clarification or course correction.
        </action>
      </on-failure>

      <status-message>executing IMPLEMENTATION/EVALUATE on {ticket-id} — {N} failures, escalating</status-message>
    </phase>

    <phase name="HUMAN_GATE" order="5">
      <actor>Orchestrator (Team Lead) presents to the human</actor>

      <presents>
        <item>Summary of what was implemented</item>
        <item>Files modified</item>
        <item>How to verify/test the changes</item>
        <item>Any concerns raised during implementation</item>
      </presents>

      <gate>BLOCKED — Do not proceed. Human approval required before continuing.</gate>
      <on-rejection>Orchestrator passes feedback to teammates or spawns new teammates → loop to DISPATCH</on-rejection>
      <status-message>awaiting IMPLEMENTATION/HUMAN_GATE on {ticket-id} — BLOCKED: human approval required</status-message>
    </phase>

    <phase name="HANDOFF" order="6">
      <description>
        TRUNK_BASED: proceed to the DOCS workflow.
        FEATURE_BRANCHING: close the child ticket, then run the beads-sync-protocol
        (see WORKFLOW_ENTRY.xml) to push the ticket close to main. Return to the orchestrator.
        The orchestrator picks the next ready child ticket, or proceeds to DOCS if all children are complete.
      </description>
      <status-message>executing IMPLEMENTATION/HANDOFF on {ticket-id} — transitioning to DOCS</status-message>
    </phase>

  </loop>

  <agent-rules>
    <!--
      These rules MUST be included in the instructions given to every implementation teammate.
      The orchestrator (team lead) is responsible for passing these to each teammate it spawns.
    -->

    <section name="commit-discipline">
      <rule>
        Every commit message starts with the ticket ID being worked (discover prefix from beads, never guess).
        In FEATURE_BRANCHING, use the child ticket ID, not the epic ID. The epic branch name
        already ties everything together.
      </rule>
      <rule>Commits must be granular — one logical change per commit</rule>
      <rule>Multiple commits per sub-task are expected</rule>
      <rule>Each commit must be atomic and independently valid (builds, no broken imports)</rule>
      <rule>Never commit secrets, .env files, or credentials</rule>
    </section>

    <section name="escalation-protocol">
      <!--
        This is the full escalation chain. Workers must understand what happens
        after they report a failure so they know they are not dying in a void.
      -->
      <rule order="1">If you encounter an error, retry once with a different approach</rule>
      <rule order="2">If the retry fails, stop immediately</rule>
      <rule order="3">Commit any partial work that is valid</rule>
      <rule order="4">
        Return a structured failure report to the orchestrator (team lead) via a message:
          FAILURE REPORT
          Sub-task: {description}
          Attempted: {what was tried}
          Error: {the error}
          Files involved: {list}
          Partial work committed: yes/no
          Suggested fix: {if any}
      </rule>
      <rule order="5">
        What happens next (you do not need to handle this — just report and stop):
        → The orchestrator (team lead) classifies your failure
        → Technical failures (logic bugs, command errors): an Opus teammate is spawned to attempt resolution
        → Requirements failures (impossible plan, unclear spec): the human is asked for clarification
        → If the Opus teammate also fails, the human is asked
      </rule>
    </section>

    <section name="scope">
      <rule>Only modify files specified in the sub-task</rule>
      <rule>
        If changes to out-of-scope files are needed:
        1. Stop work on the out-of-scope change immediately
        2. Report back to the orchestrator (team lead) with what was discovered and why it is needed
        3. Do NOT attempt the out-of-scope change — it will be tracked as a separate ticket
      </rule>
      <rule>Do not refactor, improve, or clean up code outside the sub-task scope</rule>
      <rule>
        Every change must be traceable to the ticket. If you cannot tie a change back to
        the sub-task description, do not make it.
      </rule>
    </section>

    <section name="sub-task-tracking">
      <!--
        The orchestrator (team lead) tracks sub-task progress as comments on the parent beads ticket.
        This provides an audit trail visible in the ticket history.
        See also: WORKFLOW_PLANNING.xml sub-task-tracking for the initial plan posting rule.
      -->
      <rule>Before dispatching teammates, post the sub-task plan as a comment on the ticket: bd comment {ticket-id} "..."</rule>
      <rule>As each sub-task completes, post a status update comment: "[sub-task N] DONE: {summary of changes}"</rule>
      <rule>On failure, post: "[sub-task N] FAILED: {error summary} — escalating"</rule>
    </section>
  </agent-rules>

</workflow>
