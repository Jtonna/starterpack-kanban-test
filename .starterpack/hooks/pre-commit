#!/bin/sh
#
# bd (beads) pre-commit hook
#
# This hook ensures that any pending bd issue changes are flushed to
# .beads/issues.jsonl before the commit is created, preventing the
# race condition where daemon auto-flush fires after the commit.

# Check if bd is available
if ! command -v bd >/dev/null 2>&1; then
    echo "Warning: bd command not found, skipping pre-commit flush" >&2
    exit 0
fi

# Check if we're in a bd workspace
# For worktrees, .beads is in the main repository root, not the worktree
BEADS_DIR=""
if git rev-parse --git-dir >/dev/null 2>&1; then
    # Check if we're in a worktree
    if [ "$(git rev-parse --git-dir)" != "$(git rev-parse --git-common-dir)" ]; then
        # Worktree: .beads is in main repo root
        MAIN_REPO_ROOT="$(git rev-parse --git-common-dir)"
        MAIN_REPO_ROOT="$(dirname "$MAIN_REPO_ROOT")"
        if [ -d "$MAIN_REPO_ROOT/.beads" ]; then
            BEADS_DIR="$MAIN_REPO_ROOT/.beads"
        fi
    else
        # Regular repo: check current directory
        if [ -d .beads ]; then
            BEADS_DIR=".beads"
        fi
    fi
fi

if [ -z "$BEADS_DIR" ]; then
    exit 0
fi

# Determine backend type
IS_DOLT=false
if [ -f "$BEADS_DIR/metadata.json" ]; then
    if grep -q '"backend"[[:space:]]*:[[:space:]]*"dolt"' "$BEADS_DIR/metadata.json" 2>/dev/null; then
        IS_DOLT=true
    fi
fi

# Function to flush via bd list --json export
flush_via_list() {
    # Get all issues as JSON array
    json_output=$(bd list --json --status=all 2>/dev/null)
    if [ $? -ne 0 ] || [ -z "$json_output" ]; then
        echo "Warning: bd list --json failed, skipping JSONL flush" >&2
        return 1
    fi

    # Don't overwrite with empty data
    if [ "$json_output" = "[]" ] || [ "$json_output" = "null" ]; then
        return 0
    fi

    # Convert JSON array to JSONL (one object per line)
    if command -v jq >/dev/null 2>&1; then
        echo "$json_output" | jq -c '.[]' > "$BEADS_DIR/issues.jsonl.tmp"
    else
        # Fallback: use python3 if jq not available
        echo "$json_output" | python3 -c "
import sys, json
for item in json.load(sys.stdin):
    print(json.dumps(item, separators=(',', ':')))
" > "$BEADS_DIR/issues.jsonl.tmp" 2>/dev/null
    fi

    if [ $? -eq 0 ] && [ -s "$BEADS_DIR/issues.jsonl.tmp" ]; then
        mv "$BEADS_DIR/issues.jsonl.tmp" "$BEADS_DIR/issues.jsonl"
    else
        rm -f "$BEADS_DIR/issues.jsonl.tmp"
        echo "Warning: JSONL conversion failed, skipping flush" >&2
        return 1
    fi
    return 0
}

if [ "$IS_DOLT" = "true" ]; then
    # Dolt backend: export via bd list (unused with v0.49.x)
    flush_via_list
else
    # SQLite: try bd sync --flush-only, fall back to bd list
    if ! bd sync --flush-only >/dev/null 2>&1; then
        flush_via_list
    fi
fi

# If the JSONL file was modified, stage it
# For worktrees, the JSONL is in the main repo's working tree, not the worktree,
# so we can't use git add. Skip this step for worktrees.
if [ -f "$BEADS_DIR/issues.jsonl" ]; then
    if [ "$(git rev-parse --git-dir)" = "$(git rev-parse --git-common-dir)" ]; then
        # Regular repo: file is in the working tree, safe to add
        git add "$BEADS_DIR/issues.jsonl" 2>/dev/null || true
    fi
    # For worktrees: .beads is in the main repo's working tree, not this worktree
    # Git rejects adding files outside the worktree, so we skip it.
    # The main repo will see the changes on the next pull/sync.
fi

exit 0
