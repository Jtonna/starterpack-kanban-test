<behavior name="git-with-beads">

  <summary>
    All git rules in one place: branching strategies, branch naming, commit format,
    push discipline, and beads integration. Every agent that touches git must follow these rules.
  </summary>

  <!-- ═══════════════════════════════════════════════════════════════════════
       BRANCHING STRATEGIES
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="branching-strategies">

    <strategy name="TRUNK_BASED">
      For single tickets with small, well-defined scope. One short-lived branch per ticket.
      <when>
        - The ticket is a single feature, bug, task, or chore
        - The scope fits in one planning/implementation cycle
        - No child tickets or decomposition needed
      </when>
      <flow>
        One ticket → one branch (TYPE/ticket-id) → full development cycle
        (plan, implement, document, pull request) → merge → delete branch
      </flow>
    </strategy>

    <strategy name="FEATURE_BRANCHING">
      For epics or large features that decompose into multiple tickets. One long-lived
      feature branch hosts all child ticket work. Child tickets do NOT get their own branches.
      <when>
        - The work originated from a spec file or was identified as an epic during planning
        - Multiple child tickets exist under an epic
      </when>
      <flow>
        Epic ticket → create long-lived branch (EPIC/epic-id) → for each child ticket in dependency order:
          plan and implement on the same branch → close child ticket
        → once all children complete: documentation review (full epic diff against main),
          then pull request → merge → close epic → delete branch
      </flow>
      <rules>
        <rule name="child-commits-to-epic-branch">All child tickets commit to the epic branch, not their own branches</rule>
        <rule name="child-plan-and-implement-only">Each child ticket runs planning and implementation only (no documentation review or pull request)</rule>
        <rule name="docs-review-runs-once">Documentation review runs once after all children are complete, diffing the full epic branch against main</rule>
        <rule name="pr-runs-once">A single pull request is opened at the end for the entire epic, after documentation review</rule>
        <rule name="epic-closed-last">The epic ticket is closed only after all children are closed and the pull request is merged</rule>
      </rules>
    </strategy>

  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       STRATEGY SELECTION
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="strategy-selection">
    <strategy-selection>
      The orchestrator determines the strategy during entry routing:
      - Spec file entry → FEATURE_BRANCHING (always)
      - Existing ticket with type "epic" → FEATURE_BRANCHING
      - Existing ticket with any other type → TRUNK_BASED
      - Ad-hoc request → TRUNK_BASED (unless planning reveals it should be an epic)
    </strategy-selection>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       BRANCH NAMING
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="branch-naming">
    <rule name="no-direct-main-commits">Never commit directly to main</rule>
    <rule name="all-commits-on-feature-branch">All commits happen on the feature/epic branch</rule>
    <rule name="orchestrator-creates-branch">The orchestrator creates the branch before any commits are made</rule>

    <issue-type-to-branch>
      <type name="feature" branch-prefix="FEAT/" />
      <type name="bug"     branch-prefix="BUG/" />
      <type name="task"    branch-prefix="TASK/" />
      <type name="chore"   branch-prefix="CHORE/" />
      <type name="epic"    branch-prefix="EPIC/" />
    </issue-type-to-branch>

    <examples>
      <example>git checkout -b FEAT/sp-0004</example>
      <example>git checkout -b BUG/sp-0012</example>
      <example>git checkout -b EPIC/sp-0020</example>
    </examples>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       COMMIT DISCIPLINE
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="commit-discipline">
    <rule name="ticket-id-prefix">
      Every commit message starts with the ticket ID being worked (discover prefix from beads, never guess).
      In FEATURE_BRANCHING, use the child ticket ID, not the epic ID.
    </rule>
    <rule name="granular-commits">Commits must be granular — one logical change per commit</rule>
    <rule name="multiple-commits-expected">Multiple commits per sub-task are expected</rule>
    <rule name="atomic-commits">Each commit must be atomic and independently valid (builds, no broken imports)</rule>
    <rule name="no-secrets">Never commit secrets, .env files, or credentials</rule>
    <rule name="include-beads-files">Always include .beads/ files (especially .beads/issues.jsonl) in commits — the pre-commit hook exports the database and stages issues.jsonl automatically for both SQLite and Dolt backends, but verify it is included before pushing</rule>
    <rule name="verify-build-before-final-commit">Always verify the build passes before the final commit of a task</rule>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       PUSH DISCIPLINE
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="push-discipline">
    <rule name="only-orchestrator-pushes">
      Teammates NEVER push directly. Only the orchestrator pushes, and only after human
      approval. This ensures unapproved work never reaches the remote.
    </rule>
    <rule name="push-after-implementation-approval">
      After human approval following implementation: the orchestrator pushes the branch to remote
      before handing off to the next phase. This is a single push covering all teammate commits.
    </rule>
    <rule name="push-before-pr">
      After human approval before opening the pull request: the submitter pushes any remaining
      commits (from documentation updates or ticket closure) and creates the pull request.
    </rule>
    <rule name="no-force-push">Never force-push unless the human explicitly requests it</rule>
  </section>

</behavior>
